#!/bin/bash
# SPDX-License-Identifier: GPL-2.0

if [ "${0}" == "/tmp/KEEP_ALIVE" ]; then
	echo '#!/bin/bash -l
	"${@}"
	echo > /tmp/cont_fifo' > /tmp/containers_exec
	chmod ugo+x /tmp/containers_exec
	mkfifo /tmp/cont_fifo
	chmod ugo+w /tmp/cont_fifo
	while true; do
		cat /tmp/cont_fifo
		COUNT="$(ps -e | wc -l)"
		[ "${COUNT}" -lt "6" ] && break
	done
	exit 0
fi

help_containers() {
	[ "${HELP_SEEN}" ] && return
	echo "${PNAME} - v${VERSION} - docker container management for developers"
	echo
	echo "The following commands are understood:"
	echo "help          - Show this help message."
	echo "create {name} - Create a new ${PNAME} source instance."
	echo "build {name}  - Build a docker container from a ${PNAME} source instance."
	echo "clean {name}  - Clean-up stale docker container builds."
	echo
	echo "{name} is always mandatory."
	echo "{name} must be at least 4 characters long."
	echo "{name} must not end in 'bg'."
	echo "{name} is case-insensitive."
	echo "{name} must be alphanumeric, underscores allowed only between first and last characters (a-z_0-9)."
	echo
	echo "After creating and building, the container can be entered on the command line by its name alone."
	echo "Giving its name and a command will run that command inside the container."
	echo "To run a command inside the container in background append 'bg' to the container's name."
	echo
	echo "For each ${PNAME} source instance, a directory in ${CONTAINERS_SOURCE} will be created."
	echo "Two symbolic links will also be created for each instance in ${CONTAINERS_BIN}; one ending in bg."
	echo "You may set the directory for ${PNAME} source instances in ${HOME}/.config/containers/conf.sh."
	echo "You can also set the interfacing directories location and symlink location there:"
	echo "CONTAINERS_SOURCE set to: ${CONTAINERS_SOURCE}"
	echo "CONTAINERS_ROOT set to: ${CONTAINERS_ROOT}"
	echo "CONTAINERS_BIN set to: ${CONTAINERS_BIN}"
	HELP_SEEN=1
}

return_1() {
	echo "${1}"
}

return_2() {
	echo "${2}"
}

return_3() {
	echo "${3}"
}

exists() {
	if [ -f "${CONTAINERS_SOURCE}/${1,,}/Dockerfile" ]; then
		[ "${2}" ] && error_out "${1} already exists!"
		return 0
	fi
	return 1
}

get_latest() {
	_latest="$(docker images | grep ${1,,} | grep " latest ")"
	[ "${_latest}" ] && echo -n "$(return_3 ${_latest})"
}

test_bin() {
	[ ! -d "${CONTAINERS_BIN}" ] && error_out "${CONTAINERS_BIN} does not exist! Please create!"
	[ ! "$(echo ${PATH} | grep "${CONTAINERS_BIN}")" ] && \
		error_out "${CONTAINERS_BIN} not in \$PATH! Please correct!"
}

test_name() {
	[ "${@}" == "$(basename ${0})" ] && error_out "{name} MUST not be '${@}'!"
	[[ "${@}" != *[!A-Za-z_0-9]* ]] || error_out "{name} is invalid! See --help!"
	F="${@}"
	if [ "${F::1}" == "_" ] || [ "${F::-1}_" == "${F}" ]; then
		error_out "{name} must not end or start with '_'!"
	fi
	[ "${#F}" -lt "4" ] && error_out "{name} MUST be at least 4 characters long!"
}

init_conf_sh() {
	if [ ! -d "${HOME}/.config/containers" ]; then
		mkdir -p "${HOME}/.config/containers"
	fi
	if [ ! -f "${HOME}/.config/containers/conf.sh" ]; then
		echo 'CONTAINERS_SOURCE="${HOME}/containers"' > "${HOME}/.config/containers/conf.sh"
		echo 'CONTAINERS_ROOT="${HOME}"' >> "${HOME}/.config/containers/conf.sh"
		echo 'CONTAINERS_BIN="${HOME}/bin"' >> "${HOME}/.config/containers/conf.sh"
	fi
	. "${HOME}/.config/containers/conf.sh"
	[ ! "${CONTAINERS_SOURCE}" ] && error_out "CONTAINERS_SOURCE not set in conf.sh!"
	[ ! "${CONTAINERS_ROOT}" ] && error_out "CONTAINERS_ROOT not set in conf.sh!"
	[ ! "${CONTAINERS_BIN}" ] && error_out "CONTAINERS_BIN not set in conf.sh!"
}

error_out() {
	if [ "${1}" ]; then
		help_containers
		echo
		echo "ERROR: ${1}"
	fi
	[ "${2}" ] && exit ${2}
	exit 1
}

dockerfile() {
	DF="${CONTAINERS_SOURCE}/${1,,}/Dockerfile"
	echo 'FROM debian:latest
ARG DEBIAN_FRONTEND=noninteractive
RUN apt-get update && apt-get install -q -y --no-install-recommends procps' > "${DF}"
	echo "RUN addgroup --gid $(id -g) ${USER} &&\\
 adduser --gecos \"${USER}\" --home /home/${USER} --uid $(id -u)\\
 --gid $(id -g) --disabled-password --shell /bin/bash ${USER}" >> "${DF}"
}

invoke_rc() {
	IV="${CONTAINERS_SOURCE}/${1,,}/invoke.rc.sh"
	[ -f "${IV}" ] && return
	echo "#Settings for docker
#ENVS=(ENVAR=VALUE ...)
#RUN=(--volume /home/user/db:/var/lib/db ...)
#CONT_USER_ID=0
#CONT_GROUP_ID=0
#CONT_USER=nobody
#CONT_HOME=/home/nobody" > "${IV}"
}

CREATE() {
	test_name "${@}"
	mkdir -p ${CONTAINERS_SOURCE}/${1,,}
	mkdir -p ${CONTAINERS_ROOT}/${1^^}
	[ ! -f "${CONTAINERS_SOURCE}/${1,,}/Dockerfile" ] && dockerfile ${1}
	[ ! -f "${CONTAINERS_SOURCE}/${1,,}/invoke.rc.sh" ] && invoke_rc ${1}
	[ ! -f "${CONTAINERS_BIN}/${1,,}" ] && ln -s ${0} "${CONTAINERS_BIN}/${1,,}"
	[ ! -f "${CONTAINERS_BIN}/${1,,}bg" ] && ln -s ${0} "${CONTAINERS_BIN}/${1,,}bg"
	exit 0
}

BUILD() {
	test_bin
	exists ${1} || error_out "${1,,} does not exist!"
	latest_old="$(get_latest ${1,,})"
	cd "${CONTAINERS_SOURCE}/${1,,}"
	count="$(docker images | grep ${1,,} | grep -v latest | wc -l)"
	de="$(date +%y%m%d%H%M)-${count}"
	docker build --force-rm -f Dockerfile -t "${1,,}:${de}" . || error_out "" ${?}
	docker tag "${1,,}:${de}" "${1,,}:latest"
	latest="$(get_latest ${1,,})"
	if [ "${latest}" == "${latest_old}" ]; then
		echo "INFO: No change to build! No container was build!"
		docker rmi ${1,,}:${de}
	fi
	exit 0
}

CLEAN() {
	exists ${1} || error_out "${1,,} does not exist!"
	latest="$(get_latest "${1,,}")"
	docker images | grep "${1,,}" | while read line; do
		if [ ! "$(echo "${line}" | grep "${latest}")" ]; then
			tag="$(return_2 ${line})"
			docker rmi ${1,,}:${tag}
		fi
	done
	exit 0
}

HELP() {
	help_containers
	exit 0
}

PNAME="containers"
VERSION="0.1"
init_conf_sh
NAME="$(basename ${0})"

if [ "${NAME}" == "${PNAME}" ] && [ ! "${1}" ] || [ "${1}" == "--help" ] || [ "${1}" == "-h" ]; then
	help_containers
	exit 0
fi

if [ "${NAME}" == "${PNAME}" ]; then
	for CMD in create build clean help; do
		[ "${CMD}" == "${1}" ] && break
	done
	${CMD^^} ${2}
fi

if [ "${NAME::-2}bg" == "${NAME}" ]; then
	[ ! "${1}" ] && error_out "${NAME} requires a command as argument!"
	NAME="${NAME::-2}"
	if tty -s; then
		EXEC=(-dt)
	else
		EXEC=(-d)
	fi
else
	tty -s && EXEC=(-it)
fi

DIR="${NAME^^}"
PWDLEN="${CONTAINERS_ROOT}/${DIR}"
PWDLEN=${#PWDLEN}

[ ! -d "${CONTAINERS_ROOT}/${DIR}" ] && \
	echo "working directory '${CONTAINERS_ROOT}/${DIR}' does not exist!" && exit 1
[ ! -d "${CONTAINERS_SOURCE}/${NAME}" ] && \
	echo "container build directory '${CONTAINERS_SOURCE}/${NAME}' does not exist!" && exit 1

CONT_USER_ID="$(id -u)"
CONT_GROUP_ID="$(id -g)"
CONT_USER="${USER}"
CONT_HOME="${HOME}"
[ -f "${CONTAINERS_SOURCE}/${NAME}/invoke.rc.sh" ] && . "${CONTAINERS_SOURCE}/${NAME}/invoke.rc.sh"
ENVS+=(LANG=${LANG} TERM=${TERM} COLORTERM=${COLORTERM} USER="${CONT_USER}" HOME="${CONT_HOME}")

COUNT=1
for ENV in "${@}"; do
	if [ "${ENV/=}" != "${ENV}" ]; then
		ENVS+=(${ENV})
		(( COUNT++ ))
	else
		break
	fi
done

for ENV in "${ENVS[@]}"; do
	ENVIS+=(-e ${ENV})
done

USERSET="-u ${CONT_USER_ID}:${CONT_GROUP_ID}"
RUN=(docker run "${RUN[@]}" "${EXEC[@]}" ${USERSET} \
	-v $(realpath ${0}):/tmp/KEEP_ALIVE \
	-v ${CONTAINERS_ROOT}/${DIR}:${HOME} -h ${NAME} --rm)
EXEC=(docker exec "${EXEC[@]}" ${USERSET} "${ENVIS[@]}")

if [ "${@:COUNT:1}" ] && [ "${PWD:0:${PWDLEN}}" != "${CONTAINERS_ROOT}/${DIR}" ]; then
		echo "you are not in ${CONTAINERS_ROOT}/${DIR}"
		exit 1
fi

IS_RUNNING="$(docker ps | grep " ${NAME}:latest ")"

if [ ! "${IS_RUNNING}" ]; then
	DOCKER_ID=$("${RUN[@]}" -dt -w ${CONT_HOME} ${NAME}:latest /tmp/KEEP_ALIVE)
else
	DOCKER_ID="$(return_1 ${IS_RUNNING})"
fi

if [ "${@:COUNT:1}" ]; then
	"${EXEC[@]}" -w ${HOME}/${PWD:${PWDLEN}} "${DOCKER_ID}" /tmp/containers_exec "${@:COUNT}"
else
	"${EXEC[@]}" -w ${HOME} "${DOCKER_ID}" /tmp/containers_exec /bin/bash
fi
